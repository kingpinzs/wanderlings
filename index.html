<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pixel Pathfinders - Beta</title> <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#222222">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Pathfinders">

    <style>
        body { margin: 0; overflow: hidden; background-color: #333; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; font-family: Arial, sans-serif; color: white; }
        #gameContainer { width: 100%; max-width: 600px; aspect-ratio: 4 / 3; position: relative; background-color: #000; border: 2px solid #555; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        #gameCanvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; image-rendering: crisp-edges; }
        #uiControls { display: flex; flex-wrap: wrap; justify-content: center; padding: 10px; gap: 8px; background-color: #222; width: 100%; max-width: 600px; box-sizing: border-box; }
        .skillButton { padding: 10px 15px; font-size: 14px; background-color: #5a5a5a; color: white; border: 1px solid #777; border-radius: 5px; cursor: pointer; min-width: 70px; text-align: center; }
        .skillButton.active { background-color: #77aaff; border-color: #5588dd; }
        .skillButton:disabled { background-color: #444; color: #888; cursor: not-allowed; }
        #gameInfo { display: flex; justify-content: space-around; width: 100%; max-width: 600px; padding: 5px 0; font-size: 14px; }
        #loadingScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); color: white; display: flex; justify-content: center; align-items: center; font-size: 20px; z-index: 100; }
    </style>
    <script src="levels.js" defer></script>
</head>
<body>
    <div id="gameInfo">
        <span id="lemmingsCount">Active: 0</span>
        <span id="lemmingsSaved">Saved: 0 / 0</span>
        <span id="timeLeft">Time: 0</span>
        <span id="levelName">Level: 1</span>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="loadingScreen" style="display: none;">Loading...</div>
    </div>

    <div id="uiControls"></div>

    <script>
        // --- Global Variables & Constants ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // ... (other global DOM element getters)

        let gamePaused = false;
        let currentLevelIndex = 0;
        let lemmings = [];
        let levelData = {};
        let selectedSkill = null;
        let gameTimeRemaining = 0;
        let lemmingsToSave = 0;
        let lemmingsOut = 0;
        let lemmingsRescued = 0;
        let releaseRate = 1000;
        let lastReleaseTime = 0;

        let lastTapPos = null;
        let highlightedLemming = null;
        let tapVisualTimer = 0;
        const TAP_VISUAL_DURATION = 300;
        let lastInteractionLemming = null;
        let interactionFeedbackTimer = 0;
        const INTERACTION_FEEDBACK_DURATION = 500;

        let particles = [];

        const TILE_SIZE = 16;
        const GRAVITY = 0.2;
        const WALK_SPEED = 0.5;

        const PIXEL_SCALE = 2;
        const lemmingColorPalette = {
            '0': null, 'h': '#FFFF00', 's': '#FFDBAC', 'b': '#00AA00',
            'e': '#FFFFFF', 'k': '#000000', 't': '#A0522D', 'p': '#ADD8E6', 'r': '#FF0000',
        };
        const SPRITE_PIXEL_WIDTH = 5;
        const SPRITE_PIXEL_HEIGHT = 8;
        const LEMMING_WIDTH = SPRITE_PIXEL_WIDTH * PIXEL_SCALE;
        const LEMMING_HEIGHT = SPRITE_PIXEL_HEIGHT * PIXEL_SCALE;

        const lemmingSprites = { /* ... same sprite data ... */ };
         lemmingSprites.walking = [
                ["0hhh0","0hsh0","0bkb0","bbbbb","bkbkb","0b0b0","0k0k0","00000"],
                ["0hhh0","0hsh0","0bkb0","bbbbb","bkbkb","0b0b0","00k00","00000"],
                ["0hhh0","0hsh0","0bkb0","bbbbb","bkbkb","0b0b0","k0k00","00000"],
                ["0hhh0","0hsh0","0bkb0","bbbbb","bkbkb","0b0b0","00k00","00000"]
            ];
        lemmingSprites.falling = [["0hhh0","0hsh0","0bkb0","bbbbb","bkbkb","0b0b0","k000k","00000"]];
        lemmingSprites.digger = [
                ["00000","0hhh0","0hsh0","0bkb0","bbbbb","btbtb","0bkb0","00k00"],
                ["0hhh0","0hsh0","0bkb0","bbbbb","btbtb","0bkb0","00k00","00000"]
            ];
        // Add other skill sprites here as they are developed


        const GAME_STATE = { LOADING: 'loading', MENU: 'menu', PLAYING: 'playing', LEVEL_COMPLETE: 'level_complete', GAME_OVER: 'game_over'};
        let currentGameState = GAME_STATE.LOADING;

        // --- Utility Functions ---
        function getTileAt(x, y, mapData) { /* ... same ... */ }
        function setTileAt(pixelX, pixelY, newTileChar, mapData) { /* ... same ... */ }

        function createDigParticle(x, y) {
            // Angle: Mostly up, with slight side deviation. -Math.PI / 2 is straight up.
            // Let's aim for a 30-degree cone upwards (15 degrees to each side of vertical)
            const baseAngle = -Math.PI / 2; // Straight up
            const spread = Math.PI / 12; // +/- 15 degrees (Math.PI / 6 would be 30 degrees total spread)
            const angle = baseAngle + (Math.random() * spread * 2) - spread;

            const speed = Math.random() * 0.5 + 0.2; // Reduced speed for shorter travel
            const life = Math.random() * 250 + 150; // Reduced life for shorter travel
            return {
                x: x, y: y,
                dx: Math.cos(angle) * speed,
                dy: Math.sin(angle) * speed, // dy will be negative (upwards)
                size: Math.random() * 1.5 + 1, // Smaller particles
                colorHue: 25 + Math.random() * 15,
                saturation: 50 + Math.random() * 20,
                lightnessBase: 30 + Math.random() * 15,
                life: life, initialLife: life,
                update: function(deltaTime) {
                    this.x += this.dx * (deltaTime / 16.67);
                    this.y += this.dy * (deltaTime / 16.67);
                    this.dy += GRAVITY * 0.1; // Particles still affected by some gravity
                    this.life -= deltaTime;
                },
                draw: function(ctx) { /* ... same draw logic ... */ }
            };
        }
         // Utility function to draw particles (from createDigParticle)
        createDigParticle(0,0).draw = function(ctx) { // Attach to prototype for brevity
            if (this.life <= 0) return;
            const alpha = Math.max(0, this.life / this.initialLife) * 0.8;
            const lightness = this.lightnessBase * (0.5 + (this.life / this.initialLife) * 0.5);
            ctx.fillStyle = `hsla(${this.colorHue}, ${this.saturation}%, ${lightness}%, ${alpha})`;
            ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
        };


        function drawLemmingSprite(lemming, ctx) { /* ... same ... */ }

        function createLemming(startX, startY) {
            return {
                x: startX, y: startY,
                dx: WALK_SPEED, dy: 0,
                width: LEMMING_WIDTH, height: LEMMING_HEIGHT,
                state: 'falling', isFalling: true, onGround: false,
                fallDistance: 0, isDead: false, isRescued: false,
                spriteFrame: 0, animationTimer: 0,
                id: Date.now() + Math.random() + startX,
                assignedSkill: null, skillTimer: 0, actionCounter: 0,
                digProgress: 0, // For Digger: progress within the current TILE_SIZE segment
                currentDigTileCol: -1, // For Digger: column of the tile being dug
                currentDigTileRow: -1, // For Digger: row of the tile being dug

                update: function(deltaTime, map) {
                    if (this.isDead || this.isRescued) return;
                    let skillManagesMovement = false;

                    switch (this.state) {
                        case 'blocker': skillManagesMovement = true; return;
                        case 'bomber': /* ... same ... */ break;
                        case 'builder': /* ... same ... */ break;
                        case 'digger':
                            const digStatus = this.performDigAction(map, deltaTime);
                            switch (digStatus) {
                                case 'dug_through_to_air': this.changeState('falling'); break;
                                case 'blocked': this.changeState('walking'); break;
                                case 'skill_depleted': case 'skill_depleted_mid_segment':
                                    const gbd = getTileAt(this.x + this.width / 2, this.y + this.height + 1, map);
                                    if (gbd === '0') this.changeState('falling'); else this.changeState('walking');
                                    break;
                            }
                            this.isFalling = false; this.onGround = true; 
                            skillManagesMovement = true; 
                            return; 
                        case 'miner': /* ... same simplified logic for now ... */
                            this.skillTimer -= deltaTime;
                            if (this.skillTimer <= 0) { this.dx *= -1; this.changeState('walking');}
                            skillManagesMovement = true; return;
                        case 'basher': /* ... same simplified logic for now ... */
                            this.skillTimer -= deltaTime;
                            if (this.skillTimer <= 0) { this.dx *= -1; this.changeState('walking');}
                            skillManagesMovement = true; return;
                    }

                    if (!skillManagesMovement) {
                        this.onGround = false; 
                        const feetX = this.x + this.width / 2;
                        const feetY = this.y + this.height;
                        const groundCheckY = feetY + 1;
                        let tileBelow = getTileAt(feetX, groundCheckY, map);
                        const blockerAtFeet = getLemmingBlockerAtPixel(feetX, groundCheckY);
                        if (blockerAtFeet && blockerAtFeet !== this) tileBelow = '1';

                        if (tileBelow === '1' || tileBelow === '2' || tileBelow === 'B') {
                            this.onGround = true;
                            this.y = Math.floor(groundCheckY / TILE_SIZE) * TILE_SIZE - this.height;
                            this.dy = 0;
                            if (this.isFalling) {
                                if (this.state !== 'floater' && this.fallDistance > TILE_SIZE * 3.5) { this.die("Splat!"); return; }
                                this.isFalling = false; this.fallDistance = 0;
                                if (this.state === 'falling') this.changeState('walking');
                            }
                        } else { 
                            this.onGround = false; 
                            this.dy += (this.state === 'floater' ? GRAVITY / 3 : GRAVITY);
                            this.isFalling = true; this.fallDistance += Math.abs(this.dy);
                            if (this.state === 'walking' && this.dy > 0.1) this.changeState('falling');
                        }
                        this.y += this.dy;

                        const nextXCandidate = this.x + this.dx;
                        if (this.onGround && (this.state === 'walking' || this.state === 'floater' || (this.state === 'builder' && this.actionCounter > 0 ))) {
                            const frontPixelX = this.x + (this.dx > 0 ? this.width : 0) + this.dx;
                            const midPixelY = this.y + this.height / 2;
                            const wallTileAtMid = getTileAt(frontPixelX, midPixelY, map);
                            const blockerAhead = getLemmingBlockerAtPixel(frontPixelX, midPixelY);
                            let hitWall = (wallTileAtMid === '1' || wallTileAtMid === '2' || (blockerAhead && blockerAhead !== this));
                            
                            if (this.state === 'walking') {
                                const lookAheadX = this.x + (this.dx > 0 ? this.width + 2 : -2);
                                const lookDownY = this.y + this.height + (TILE_SIZE / 2);
                                const groundBelowFront = getTileAt(lookAheadX, lookDownY, map);
                                const blockerBelowFront = getLemmingBlockerAtPixel(lookAheadX, lookDownY);
                                if ((groundBelowFront === '0' || groundBelowFront === undefined) && !blockerBelowFront) {
                                    this.x = nextXCandidate; 
                                } else if (hitWall) { this.dx *= -1; 
                                } else { this.x = nextXCandidate; }
                            } else if (hitWall) { 
                                 if (this.state === 'builder') { this.dx *= -1; this.changeState('walking');
                                } else { this.dx *= -1; }
                            } else {
                                this.x = nextXCandidate; 
                            }
                        } else if (!this.onGround && this.state !== 'blocker' && this.state !== 'digger') {
                            this.x = nextXCandidate; 
                        }
                    }
                    
                    if (this.y > canvas.height + this.height * 2 || this.x < -this.width || this.x > canvas.width) { this.die("Lost..."); return; }
                    const exitRect = { x: levelData.exitPoint.x * TILE_SIZE, y: levelData.exitPoint.y * TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE };
                    if (this.x + this.width > exitRect.x && this.x < exitRect.x + exitRect.width &&
                        this.y + this.height > exitRect.y && this.y < exitRect.y + exitRect.height) { this.rescue(); }

                    this.animationTimer += deltaTime;
                    let animSpeed = 200; let numFrames = 1;
                    if (lemmingSprites[this.state]) numFrames = lemmingSprites[this.state].length;
                    if (this.state === 'walking' || this.state === 'floater') animSpeed = (this.state === 'falling' && !this.onGround) ? 300 : 150;
                    else if (this.state === 'bomber') animSpeed = 100;
                    else if (this.state === 'digger' || this.state === 'miner' || this.state === 'basher') animSpeed = 250;
                    if (numFrames > 0 && this.animationTimer > animSpeed) {
                        this.spriteFrame = (this.spriteFrame + 1) % numFrames;
                        this.animationTimer = 0;
                    }
                },

                draw: function(ctx) {
                    if (this.isDead || this.isRescued) { /* ... death visuals ... */ return; }
                    
                    drawLemmingSprite(this, ctx);

                    // Visual for Digger's progress
                    if (this.state === 'digger' && this.digProgress > 0 && this.currentDigTileCol !== -1 && this.currentDigTileRow !== -1) {
                        const tileX = this.currentDigTileCol * TILE_SIZE;
                        const tileY = this.currentDigTileRow * TILE_SIZE;
                        const holeHeight = this.digProgress * (TILE_SIZE / TILE_SIZE); // digProgress is already in pixels up to TILE_SIZE

                        ctx.fillStyle = "rgba(0, 0, 0, 0.6)"; // Semi-transparent black for the hole
                        ctx.fillRect(tileX, tileY, TILE_SIZE, Math.min(holeHeight, TILE_SIZE));
                    }


                    if (this === highlightedLemming || (this === lastInteractionLemming && interactionFeedbackTimer > 0)) {
                        /* ... highlight logic ... */
                    }
                    if (this.state === 'bomber') { /* ... timer text ... */ }
                    if (this.state === 'builder' && this.actionCounter > 0) { /* ... counter text ... */ }
                },
                changeState: function(newState) {
                    if (this.state === newState && newState !== 'bomber') return;
                    console.log(`Lemming ${this.id.toString().slice(-4)} ${this.state} -> ${newState}`);
                    const oldState = this.state;
                    this.state = newState;
                    this.skillTimer = 0; this.animationTimer = 0; this.spriteFrame = 0;
                    switch (newState) {
                        case 'blocker': this.dx = 0; this.dy = 0; break;
                        case 'bomber': this.skillTimer = 5000; break;
                        case 'builder': this.actionCounter = 12; this.skillTimer = 200; break;
                        case 'digger':
                            this.actionCounter = TILE_SIZE * 3.5; this.dx = 0; this.dy = 0;
                            this.digProgress = 0; 
                            // Set currentDigTileCol and currentDigTileRow when digging starts in performDigAction
                            this.currentDigTileCol = -1; 
                            this.currentDigTileRow = -1;
                            this.isFalling = false; this.onGround = true;
                            break;
                        case 'miner': case 'basher':
                            this.actionCounter = 15; this.skillTimer = (newState === 'miner' ? 400 : 300);
                            this.dy = 0; this.isFalling = false; this.onGround = true;
                            break;
                        case 'walking':
                            if (oldState === 'blocker' || (this.dx === 0 && oldState !== 'digger' && oldState !== 'miner' && oldState !== 'basher')) {
                                this.dx = WALK_SPEED * (Math.random() < 0.5 ? 1 : -1);
                            }
                            break;
                    }
                },
                assignSkill: function(skillName) { /* ... same ... */ },
                dig: function(map, offsetXTile, offsetYTile) { /* ... same generic dig for miner/basher ... */ },
                performDigAction: function(map, deltaTime) {
                    if (this.actionCounter <= 0) return 'skill_depleted';
                    const digSpeed = WALK_SPEED * 0.65; // pixels per second
                    const digAmountThisFrame = digSpeed * (deltaTime / 1000);
                    
                    const digCenterX = this.x + this.width / 2;

                    if (this.currentDigTileCol === -1) { // Initialize dig target tile
                        this.currentDigTileCol = Math.floor(digCenterX / TILE_SIZE);
                        this.currentDigTileRow = Math.floor((this.y + this.height) / TILE_SIZE); // Tile lemming is standing on/just above
                        this.digProgress = 0; // Reset progress for this new tile
                    }
                    
                    // Point where digging is happening, relative to the top of the currentDigTileRow
                    const diggingPointInTileY = this.digProgress; 
                    const absoluteDiggingPointY = this.currentDigTileRow * TILE_SIZE + diggingPointInTileY;


                    const tileCharAhead = getTileAt(this.currentDigTileCol * TILE_SIZE + TILE_SIZE/2, absoluteDiggingPointY + 1, map);
                    if (tileCharAhead === '1' || tileCharAhead === 'E' || tileCharAhead === 'X' || tileCharAhead === undefined) {
                        return 'blocked';
                    }

                    this.digProgress += digAmountThisFrame;
                    this.y += digAmountThisFrame; // Lemming moves down with the digging
                    this.actionCounter -= digAmountThisFrame;

                    if (Math.random() < 0.8) {
                        for (let p = 0; p < Math.ceil(deltaTime/16); p++) {
                            particles.push(createDigParticle(
                                digCenterX + (Math.random() - 0.5) * (this.width * 0.6),
                                this.y + this.height - (this.digProgress / 2) + (Math.random() * 4 - 2) 
                            ));
                        }
                    }

                    if (this.digProgress >= TILE_SIZE) {
                        const pixelXToClear = this.currentDigTileCol * TILE_SIZE + TILE_SIZE / 2;
                        const pixelYToClear = this.currentDigTileRow * TILE_SIZE + TILE_SIZE / 2;
                        if (getTileAt(pixelXToClear, pixelYToClear, map) === '2') {
                             setTileAt(pixelXToClear, pixelYToClear, '0', map);
                        }
                        this.digProgress = 0; // Reset for the next potential segment below
                        this.currentDigTileRow++; // Move to the next row for tracking
                        // this.currentDigTileCol remains the same unless a new dig action is initiated elsewhere

                        const groundDirectlyBelow = getTileAt(digCenterX, this.y + this.height + 1, map);
                        if (groundDirectlyBelow === '0') return 'dug_through_to_air';
                        return 'finished_segment';
                    }
                    if (this.actionCounter <= 0) return 'skill_depleted_mid_segment';
                    return 'digging';
                },
                buildStep: function(map) { /* ... same ... */ },
                explode: function(map) { /* ... same ... */ },
                die: function(reason) { /* ... same ... */ },
                rescue: function() { /* ... same ... */ }
            };
        }

        function getLemmingBlockerAtPixel(pixelX, pixelY) { /* ... same ... */ }
        let lastTime = 0;
        function gameLoop(timestamp) { /* ... same ... */ }
        
        function update(deltaTime) {
            if (deltaTime <= 0 || deltaTime > 500) {
                if (deltaTime <=0 && deltaTime !== 0) { return; }
                if (deltaTime > 500) deltaTime = 500; 
            }
            if (gamePaused || currentGameState !== GAME_STATE.PLAYING) return;

            const currentTime = performance.now();
            gameTimeRemaining -= deltaTime;
            
            let activeLemmingsCount = 0;
            for(const lem of lemmings) { if(!lem.isDead && !lem.isRescued) activeLemmingsCount++; }

            // --- Win/Loss Condition Logic ---
            let levelShouldEnd = false;
            let playerWon = false;

            if (gameTimeRemaining <= 0) {
                levelShouldEnd = true;
                console.log("Level end: Time up.");
            } else if (levelData.lemmingsToRelease && lemmingsOut >= levelData.lemmingsToRelease && activeLemmingsCount === 0) {
                // All lemmings released and all are resolved (dead or rescued)
                levelShouldEnd = true;
                console.log("Level end: All lemmings processed.");
            }

            if (levelShouldEnd) {
                if (lemmingsRescued >= lemmingsToSave) {
                    playerWon = true;
                    console.log("Player Won! Saved:", lemmingsRescued, "Needed:", lemmingsToSave);
                    // Future: Add bonus calculation here
                } else {
                    playerWon = false;
                    console.log("Player Lost. Saved:", lemmingsRescued, "Needed:", lemmingsToSave);
                }
                endLevel(playerWon);
                return; // Stop further updates this frame as level is ending
            }

            // Lemming Release
            if (levelData.lemmingsToRelease && lemmingsOut < levelData.lemmingsToRelease && currentTime - lastReleaseTime > (levelData.releaseRate || 1000)) {
                const entryX = levelData.entryPoint.x * TILE_SIZE + (TILE_SIZE - LEMMING_WIDTH) / 2;
                const entryY = levelData.entryPoint.y * TILE_SIZE;
                lemmings.push(createLemming(entryX, entryY));
                lemmingsOut++;
                lastReleaseTime = currentTime;
            }

            // Update Lemmings
            for (let i = lemmings.length - 1; i >= 0; i--) {
                lemmings[i].update(deltaTime, levelData.map);
            }

            // Update Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(deltaTime);
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            updateGameInfo();
        }

        function render(deltaTime) { /* ... same ... */ }
        function getTouchPos(canvasDom, touchEvent) { /* ... same ... */ }
        function handleCanvasTap(event) { /* ... same ... */ }
        canvas.addEventListener('touchstart', handleCanvasTap, { passive: false });
        
        function setupSkillButtons() { /* ... (Full implementation from previous correct version) ... */ }
        function updateSkillButtons() { /* ... (Full implementation from previous correct version) ... */ }
        function updateGameInfo() { /* ... (Full implementation from previous correct version) ... */ }
        function showLoadingScreen(show) { /* ... (Full implementation from previous correct version) ... */ }
        function simulateLoading() { /* ... (Full implementation from previous correct version) ... */ }
        function startLevel(levelIndex) { /* ... (Full implementation from previous correct version, uses gameLevels) ... */ }
        function endLevel(success) { /* ... (Full implementation from previous correct version) ... */ }
        
        function init() {
            // Ensure all global DOM elements are fetched
            const lemmingsCountEl = document.getElementById('lemmingsCount');
            const lemmingsSavedEl = document.getElementById('lemmingsSaved');
            const timeLeftEl = document.getElementById('timeLeft');
            const levelNameEl = document.getElementById('levelName');
            const loadingScreen = document.getElementById('loadingScreen');


            if (typeof gameLevels === 'undefined') {
                console.error("gameLevels is not defined. Ensure levels.js is loaded before this script.");
                alert("Error: Level data not found! Check console.");
                if(loadingScreen) loadingScreen.innerHTML = "Error loading levels!";
                if(showLoadingScreen) showLoadingScreen(true); 
                return;
            }
            lastReleaseTime = performance.now();
            simulateLoading();
            requestAnimationFrame(gameLoop);
        }
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
