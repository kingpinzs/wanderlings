<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#222222">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Lemmings">
    <title>Mobile Lemmings-like Game - Debugging Movement</title>
    <style>
        /* CSS for layout, game canvas, UI elements, and mobile responsiveness */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            background-color: #333;
            display: flex;
            flex-direction: column; /* Stack game and controls */
            align-items: center;
            justify-content: center;
            height: 100vh; /* Full viewport height */
            font-family: Arial, sans-serif;
            color: white;
        }

        #gameContainer {
            width: 100%;
            max-width: 600px; /* Max width for larger screens, adjust as needed */
            aspect-ratio: 4 / 3; /* Or your desired game aspect ratio */
            position: relative; /* For positioning elements within */
            background-color: #000;
            border: 2px solid #555;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        #gameCanvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* Ensures sharp pixels when scaling */
            image-rendering: crisp-edges; /* For Firefox */
        }

        #uiControls {
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
            justify-content: center;
            padding: 10px;
            gap: 8px; /* Spacing between buttons */
            background-color: #222;
            width: 100%;
            max-width: 600px; /* Match game container */
            box-sizing: border-box; /* Include padding in width calculation */
        }

        .skillButton {
            padding: 10px 15px;
            font-size: 14px;
            background-color: #5a5a5a;
            color: white;
            border: 1px solid #777;
            border-radius: 5px;
            cursor: pointer;
            min-width: 60px; /* Minimum width for touchability */
            text-align: center;
        }

        .skillButton.active {
            background-color: #77aaff;
            border-color: #5588dd;
        }

        .skillButton:disabled {
            background-color: #444;
            color: #888;
            cursor: not-allowed;
        }

        #gameInfo {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 600px;
            padding: 5px 0;
            font-size: 14px;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            z-index: 100;
        }
    </style>
    <script src="levels.js" defer></script>
</head>
<body>
    <div id="gameInfo">
        <span id="lemmingsCount">Lemmings: 0/0</span>
        <span id="lemmingsSaved">Saved: 0</span>
        <span id="timeLeft">Time: 0</span>
        <span id="levelName">Level: 1</span>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="loadingScreen" style="display: none;">Loading...</div>
    </div>

    <div id="uiControls">
    </div>

    <script>
        // --- Global Variables & Constants ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const uiControls = document.getElementById('uiControls');
        const lemmingsCountEl = document.getElementById('lemmingsCount');
        const lemmingsSavedEl = document.getElementById('lemmingsSaved');
        const timeLeftEl = document.getElementById('timeLeft');
        const levelNameEl = document.getElementById('levelName');
        const loadingScreen = document.getElementById('loadingScreen');

        let gamePaused = false;
        let currentLevelIndex = 0;
        let lemmings = [];
        let levelData = {};
        let selectedSkill = null;
        let gameTimeRemaining = 0;
        let lemmingsToSave = 0;
        let lemmingsOut = 0;
        let lemmingsRescued = 0;
        let releaseRate = 1000;
        let lastReleaseTime = 0;

        let lastTapPos = null;
        let highlightedLemming = null;
        let tapVisualTimer = 0;
        const TAP_VISUAL_DURATION = 300;
        let lastInteractionLemming = null;
        let interactionFeedbackTimer = 0;
        const INTERACTION_FEEDBACK_DURATION = 500;

        let particles = [];

        const TILE_SIZE = 16;
        const GRAVITY = 0.2;
        const WALK_SPEED = 0.5;

        const PIXEL_SCALE = 2;
        const lemmingColorPalette = {
            '0': null, 'h': '#FFFF00', 's': '#FFDBAC', 'b': '#00AA00',
            'e': '#FFFFFF', 'k': '#000000', 't': '#A0522D', 'p': '#ADD8E6', 'r': '#FF0000',
        };
        const SPRITE_PIXEL_WIDTH = 5;
        const SPRITE_PIXEL_HEIGHT = 8;
        const LEMMING_WIDTH = SPRITE_PIXEL_WIDTH * PIXEL_SCALE;
        const LEMMING_HEIGHT = SPRITE_PIXEL_HEIGHT * PIXEL_SCALE;

        const lemmingSprites = {
            walking: [
                ["0hhh0","0hsh0","0bkb0","bbbbb","bkbkb","0b0b0","0k0k0","00000"],
                ["0hhh0","0hsh0","0bkb0","bbbbb","bkbkb","0b0b0","00k00","00000"],
                ["0hhh0","0hsh0","0bkb0","bbbbb","bkbkb","0b0b0","k0k00","00000"],
                ["0hhh0","0hsh0","0bkb0","bbbbb","bkbkb","0b0b0","00k00","00000"]
            ],
            falling: [["0hhh0","0hsh0","0bkb0","bbbbb","bkbkb","0b0b0","k000k","00000"]],
            digger: [
                ["00000","0hhh0","0hsh0","0bkb0","bbbbb","btbtb","0bkb0","00k00"],
                ["0hhh0","0hsh0","0bkb0","bbbbb","btbtb","0bkb0","00k00","00000"]
            ],
        };

        const GAME_STATE = { LOADING: 'loading', MENU: 'menu', PLAYING: 'playing', LEVEL_COMPLETE: 'level_complete', GAME_OVER: 'game_over'};
        let currentGameState = GAME_STATE.LOADING;

        // --- Utility Functions ---
        function getTileAt(x, y, mapData) {
            const tileX = Math.floor(x / TILE_SIZE);
            const tileY = Math.floor(y / TILE_SIZE);
            if (mapData && mapData[tileY] && mapData[tileY][tileX] !== undefined) {
                return mapData[tileY][tileX];
            }
            return '1';
        }

        function setTileAt(pixelX, pixelY, newTileChar, mapData) {
            const tileX = Math.floor(pixelX / TILE_SIZE);
            const tileY = Math.floor(pixelY / TILE_SIZE);
            if (mapData && mapData[tileY] && mapData[tileY][tileX] !== undefined) {
                let rowArray = mapData[tileY].split('');
                rowArray[tileX] = newTileChar;
                mapData[tileY] = rowArray.join('');
                return true;
            }
            return false;
        }

        function createDigParticle(x, y) {
            const angle = Math.random() * Math.PI - Math.PI * 1.7;
            const speed = Math.random() * 1.2 + 0.3;
            const life = Math.random() * 450 + 250;
            return {
                x: x, y: y,
                dx: Math.cos(angle) * speed,
                dy: Math.sin(angle) * speed,
                size: Math.random() * 2.5 + 1.5,
                colorHue: 25 + Math.random() * 15,
                saturation: 50 + Math.random() * 20,
                lightnessBase: 30 + Math.random() * 15,
                life: life, initialLife: life,
                update: function(deltaTime) {
                    this.x += this.dx * (deltaTime / 16.67);
                    this.y += this.dy * (deltaTime / 16.67);
                    this.dy += GRAVITY * 0.08;
                    this.life -= deltaTime;
                },
                draw: function(ctx) {
                    if (this.life <= 0) return;
                    const alpha = Math.max(0, this.life / this.initialLife) * 0.8;
                    const lightness = this.lightnessBase * (0.5 + (this.life / this.initialLife) * 0.5);
                    ctx.fillStyle = `hsla(${this.colorHue}, ${this.saturation}%, ${lightness}%, ${alpha})`;
                    ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                }
            };
        }

        function drawLemmingSprite(lemming, ctx) {
            const stateSprites = lemmingSprites[lemming.state];
            if (!stateSprites) {
                ctx.fillStyle = 'magenta'; 
                ctx.fillRect(lemming.x, lemming.y, LEMMING_WIDTH, LEMMING_HEIGHT);
                return;
            }
            const frameIndex = lemming.spriteFrame % stateSprites.length;
            const spriteFrameData = stateSprites[frameIndex];
            if (!spriteFrameData) {
                ctx.fillStyle = 'cyan';
                ctx.fillRect(lemming.x, lemming.y, LEMMING_WIDTH, LEMMING_HEIGHT);
                return;
            }
            const spritePixelHeight = spriteFrameData.length;
            const spritePixelWidth = spriteFrameData[0] ? spriteFrameData[0].length : 0;
            for (let r = 0; r < spritePixelHeight; r++) {
                for (let c = 0; c < spritePixelWidth; c++) {
                    const pixelColorCode = spriteFrameData[r][c];
                    const color = lemmingColorPalette[pixelColorCode];
                    if (color) {
                        const drawXOffset = lemming.dx >= 0 ? c : (spritePixelWidth - 1 - c);
                        ctx.fillStyle = color;
                        ctx.fillRect(
                            Math.floor(lemming.x + drawXOffset * PIXEL_SCALE),
                            Math.floor(lemming.y + r * PIXEL_SCALE),
                            PIXEL_SCALE, PIXEL_SCALE
                        );
                    }
                }
            }
        }

        function createLemming(startX, startY) {
            return {
                x: startX, y: startY,
                dx: WALK_SPEED, dy: 0,
                width: LEMMING_WIDTH, height: LEMMING_HEIGHT,
                state: 'falling',
		isFalling: true,
		onGround: false,
                fallDistance: 0,
		isDead: false,
		isRescued: false,
                spriteFrame: 0, animationTimer: 0,
                id: Date.now() + Math.random() + startX,
                assignedSkill: null,
		skillTimer: 0,
		actionCounter: 0,
                digProgress: 0,
		currentDigTileY: -1,

                update: function(deltaTime, map) {
                    if (this.isDead || this.isRescued) return;

                    // DEBUG: Log initial state for the first lemming
                    // if (lemmings.length > 0 && this.id === lemmings[0].id) {
                    //      console.log(`L[${this.id.toString().slice(-4)}] START: x=${this.x.toFixed(1)},y=${this.y.toFixed(1)},dx=${this.dx.toFixed(1)},dy=${this.dy.toFixed(1)},st=${this.state},onG=${this.onGround},isF=${this.isFalling}`);
                    // }

                    let skillManagesMovement = false; // Flag to see if a skill fully handles movement

                    switch (this.state) {
                        case 'blocker': 
                            skillManagesMovement = true; // Blocker doesn't move
                            return; // No further updates for blocker
                        case 'bomber':
                            this.skillTimer -= deltaTime;
			    this.animationTimer += deltaTime;
                            if (this.skillTimer <= 0) {
			        this.explode(map);
				return;
			    }
                            // Bomber doesn't move on its own, but can be pushed by physics if not returning
                            break; 
                        case 'builder':
                            if (this.actionCounter <= 0) {
			        this.changeState('walking');
				break;
			    }
                            this.skillTimer -= deltaTime;
                            if (this.skillTimer <= 0) {
                                if (this.buildStep(map)) {
                                    this.actionCounter--;
				    this.skillTimer = 1200;
                                    this.x += this.dx * TILE_SIZE * 0.75;
				    this.y -= TILE_SIZE * 0.25;
                                    skillManagesMovement = true; // Builder moves itself onto the step
                                } else { this.dx *= -1; this.changeState('walking'); }
                            } else {
                                skillManagesMovement = true; // Builder is waiting to build, no general physics
                            }
                            break;
                        case 'digger':
                            const digStatus = this.performDigAction(map, deltaTime);
                            switch (digStatus) {
                                case 'dug_through_to_air': this.changeState('falling'); break;
                                case 'blocked': this.changeState('walking'); break;
                                case 'skill_depleted': case 'skill_depleted_mid_segment':
                                    const gbd = getTileAt(this.x + this.width / 2, this.y + this.height + 1, map);
                                    if (gbd === '0') this.changeState('falling'); else this.changeState('walking');
                                    break;
                            }
                            this.isFalling = false; this.onGround = true; 
                            skillManagesMovement = true; // Digger controls its own Y
                            return; // Digger bypasses normal physics
                        case 'miner': 
                            this.skillTimer -= deltaTime;
                            if (this.skillTimer <= 0) {
                                // console.log(`Miner ID ${this.id.toString().substring(0,4)} - Miner skill active, TEMPORARILY turning.`);
                                // For now, just turn around and become walker to test general movement
                                this.dx *= -1;
                                this.changeState('walking');
                            }
                            skillManagesMovement = true; // Miner controls its own movement (even if simplified)
                            return; 
                        case 'basher': 
                            this.skillTimer -= deltaTime;
                            if (this.skillTimer <= 0) {
                                // console.log(`Basher ID ${this.id.toString().substring(0,4)} - Basher skill active, TEMPORARILY turning.`);
                                this.dx *= -1;
                                this.changeState('walking');
                            }
                            skillManagesMovement = true; // Basher controls its own movement (even if simplified)
                            return; 
                    }

                    // --- General Physics (Applied if skill doesn't fully manage movement) ---
                    if (!skillManagesMovement) {
                        this.onGround = false; 
                        const feetX = this.x + this.width / 2;
                        const feetY = this.y + this.height;
                        const groundCheckY = feetY + 1;
                        let tileBelow = getTileAt(feetX, groundCheckY, map);
                        const blockerAtFeet = getLemmingBlockerAtPixel(feetX, groundCheckY);
                        if (blockerAtFeet && blockerAtFeet !== this) tileBelow = '1';

                        if (tileBelow === '1' || tileBelow === '2' || tileBelow === 'B') {
                            this.onGround = true;
                            this.y = Math.floor(groundCheckY / TILE_SIZE) * TILE_SIZE - this.height;
                            this.dy = 0;
                            if (this.isFalling) {
                                if (this.state !== 'floater' && this.fallDistance > TILE_SIZE * 3.5) { this.die("Splat!"); return; }
                                this.isFalling = false; this.fallDistance = 0;
                                if (this.state === 'falling') this.changeState('walking');
                            }
                        } else { 
                            this.onGround = false; 
                            this.dy += (this.state === 'floater' ? GRAVITY / 3 : GRAVITY);
                            this.isFalling = true; this.fallDistance += Math.abs(this.dy);
                            if (this.state === 'walking' && this.dy > 0.1) this.changeState('falling');
                        }
                        this.y += this.dy; // Apply vertical movement

                        // Apply horizontal movement (walking, falling with momentum)
                        const nextXCandidate = this.x + this.dx;
                        if (this.onGround && (this.state === 'walking' || this.state === 'floater' || (this.state === 'builder' && this.actionCounter > 0 ))) {
                            const frontPixelX = this.x + (this.dx > 0 ? this.width : 0) + this.dx;
                            const midPixelY = this.y + this.height / 2;
                            const wallTileAtMid = getTileAt(frontPixelX, midPixelY, map);
                            const blockerAhead = getLemmingBlockerAtPixel(frontPixelX, midPixelY);
                            let hitWall = (wallTileAtMid === '1' || wallTileAtMid === '2' || (blockerAhead && blockerAhead !== this));
                            
                            if (this.state === 'walking') {
                                const lookAheadX = this.x + (this.dx > 0 ? this.width + 2 : -2);
                                const lookDownY = this.y + this.height + (TILE_SIZE / 2);
                                const groundBelowFront = getTileAt(lookAheadX, lookDownY, map);
                                const blockerBelowFront = getLemmingBlockerAtPixel(lookAheadX, lookDownY);
                                if ((groundBelowFront === '0' || groundBelowFront === undefined) && !blockerBelowFront) {
                                    this.x = nextXCandidate; // Walk off edge
                                } else if (hitWall) { this.dx *= -1; 
                                } else { this.x = nextXCandidate; }
                            } else if (hitWall) { 
                                 if (this.state === 'builder') { this.dx *= -1; this.changeState('walking');
                                } else { this.dx *= -1; } // Floater on ground turns at wall
                            } else {
                                this.x = nextXCandidate; 
                            }
                        } else if (!this.onGround) { // If falling or floater in air
                            this.x = nextXCandidate; // Continue horizontal momentum
                        }
                    }
                    
                    // DEBUG: Log final state for the first lemming
                    // if (lemmings.length > 0 && this.id === lemmings[0].id) {
                    //      console.log(`L[${this.id.toString().slice(-4)}] END:   x=${this.x.toFixed(1)},y=${this.y.toFixed(1)},dx=${this.dx.toFixed(1)},dy=${this.dy.toFixed(1)},st=${this.state},onG=${this.onGround},isF=${this.isFalling}`);
                    // }

                    if (this.y > canvas.height + this.height * 2 || this.x < -this.width || this.x > canvas.width) { this.die("Lost..."); return; }
                    const exitRect = { x: levelData.exitPoint.x * TILE_SIZE, y: levelData.exitPoint.y * TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE };
                    if (this.x + this.width > exitRect.x && this.x < exitRect.x + exitRect.width &&
                        this.y + this.height > exitRect.y && this.y < exitRect.y + exitRect.height) { this.rescue(); }

                    this.animationTimer += deltaTime;
                    let animSpeed = 200; let numFrames = 1;
                    if (lemmingSprites[this.state]) numFrames = lemmingSprites[this.state].length;
                    
                    if (this.state === 'walking' || this.state === 'floater') animSpeed = (this.state === 'falling' && !this.onGround) ? 300 : 150;
                    else if (this.state === 'bomber') animSpeed = 100;
                    else if (this.state === 'digger' || this.state === 'miner' || this.state === 'basher') animSpeed = 250;

                    if (numFrames > 0 && this.animationTimer > animSpeed) {
                        this.spriteFrame = (this.spriteFrame + 1) % numFrames;
                        this.animationTimer = 0;
                    }
                },

                draw: function(ctx) {
                    if (this.isDead || this.isRescued) {
                        if (this.isDead && this.state === 'dead_splat') {
                            ctx.fillStyle = 'darkred'; ctx.beginPath();
                            ctx.ellipse(this.x + this.width / 2, this.y + this.height - 3, this.width / 1.5, 3, 0, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (this.isDead && this.state === 'dead_explode') {
                            ctx.fillStyle = 'orange'; ctx.beginPath();
                            ctx.ellipse(this.x + this.width / 2, this.y + this.height/2, this.width * 0.8, this.height*0.8, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return;
                    }
                    drawLemmingSprite(this, ctx);
                    if (this === highlightedLemming || (this === lastInteractionLemming && interactionFeedbackTimer > 0)) {
                        ctx.strokeStyle = (this === lastInteractionLemming && interactionFeedbackTimer > 0) ? 'cyan' : 'yellow';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this.x -1, this.y -1, LEMMING_WIDTH + 2, LEMMING_HEIGHT + 2);
                        ctx.lineWidth = 1;
                    }
                    if (this.state === 'bomber') {
                        ctx.fillStyle = 'white'; ctx.font = '10px Arial'; ctx.textAlign = 'center';
                        ctx.fillText(Math.ceil(this.skillTimer / 1000), this.x + this.width / 2, this.y - 2);
                    }
                    if (this.state === 'builder' && this.actionCounter > 0) {
                        ctx.fillStyle = 'black'; ctx.font = '10px Arial'; ctx.textAlign = 'center';
                        ctx.fillText(this.actionCounter, this.x + this.width / 2, this.y - 2);
                    }
                },
                changeState: function(newState) {
                    if (this.state === newState && newState !== 'bomber') return;
                    console.log(`Lemming ${this.id.toString().slice(-4)} ${this.state} -> ${newState}`);
                    const oldState = this.state;
                    this.state = newState;
                    this.skillTimer = 0;
		    this.animationTimer = 0;
		    this.spriteFrame = 0;
                    switch (newState) {
                        case 'blocker': this.dx = 0; this.dy = 0; break;
                        case 'bomber': this.skillTimer = 5000; break;
                        case 'builder': this.actionCounter = 12;
			this.skillTimer = 200; break;
                        case 'digger':
                            this.actionCounter = TILE_SIZE * 3.5;
			    this.dx = 0; this.dy = 0;
                            this.digProgress = 0; this.currentDigTileY = -1;
                            this.isFalling = false; this.onGround = true;
                            break;
                        case 'miner':
			case 'basher':
                            this.actionCounter = 15;
			    this.skillTimer = (newState === 'miner' ? 400 : 300);
                            this.dy = 0; this.isFalling = false; this.onGround = true;
                            break;
                        case 'walking':
                            if (oldState === 'blocker' || this.dx === 0 && oldState !== 'digger') { // Diggers changing to walk should keep dx=0 until they land
                                this.dx = WALK_SPEED * (Math.random() < 0.5 ? 1 : -1);
                            }
                            break;
                    }
                },
                assignSkill: function(skillName) {
                    if (!(this.state === 'walking' || this.state === 'falling' || this.state === 'floater')) {
                        console.warn(`Lemming ${this.id.toString().slice(-4)}: Cannot assign skill. Invalid state: ${this.state}.`); return false;
                    }
                    const skillCount = levelData.availableSkills[skillName];
                    if (!(skillCount > 0 || skillCount === Infinity)) {
                        console.warn(`Lemming ${this.id.toString().slice(-4)}: Skill '${skillName}' not available (${skillCount}).`); return false;
                    }
                    this.changeState(skillName); this.assignedSkill = skillName;
                    if (skillCount !== Infinity) levelData.availableSkills[skillName]--;
                    updateSkillButtons(); return true;
                },
                dig: function(map, offsetXTile, offsetYTile) {
                    console.log(`Generic 'dig' called by ${this.state}.`);
                    let success = false; let targetPixelX, targetPixelY;
                    if (this.state === 'miner') {
                        targetPixelX = this.x + (this.dx > 0 ? this.width : 0) + (this.dx * TILE_SIZE * 0.6);
                        targetPixelY = this.y + this.height + (TILE_SIZE * 0.4);
                    } else if (this.state === 'basher') {
                        targetPixelX = this.x + (this.dx > 0 ? this.width + 2 : -2 - TILE_SIZE/2) + (TILE_SIZE/2);
                        targetPixelY = this.y + this.height / 2;
                    } else { return false; }
                    const tileToDig = getTileAt(targetPixelX, targetPixelY, map);
                    // console.log(`Generic 'dig' for ${this.state} targeting tile: '${tileToDig}'`);
                    if (tileToDig === '2') { setTileAt(targetPixelX, targetPixelY, '0', map); success = true;
                    } else if (tileToDig === '1' || tileToDig === 'E' || tileToDig === 'X') { success = false; 
                    } else if (tileToDig === '0') { success = false; }
                    return success;
                },

                performDigAction: function(map, deltaTime) { // Specifically for Digger skill
                    if (this.actionCounter <= 0) return 'skill_depleted';
                    const digSpeed = WALK_SPEED * 0.65;
                    const digAmountThisFrame = digSpeed * (deltaTime / 1000);
                    const digCenterX = this.x + this.width / 2;
                    const diggingPointY = this.y + this.height + this.digProgress;

                    if (this.currentDigTileY === -1) {
                        this.currentDigTileY = Math.floor((this.y + this.height) / TILE_SIZE);
                    }
                    const tileCharAhead = getTileAt(digCenterX, diggingPointY + 1, map);
                    if (tileCharAhead === '1' || tileCharAhead === 'E' || tileCharAhead === 'X' || tileCharAhead === undefined) {
                        return 'blocked';
                    }
                    this.digProgress += digAmountThisFrame;
                    this.y += digAmountThisFrame;
                    this.actionCounter -= digAmountThisFrame;

                    if (Math.random() < 0.8) {
                        for (let p = 0; p < Math.ceil(deltaTime/16); p++) {
                            const newParticle = createDigParticle(
                                digCenterX + (Math.random() - 0.5) * (this.width * 0.6),
                                this.y + this.height - (this.digProgress / 2) + (Math.random() * 4 - 2)
                            );
                            particles.push(newParticle);
                            // console.log("Particle CREATED & PUSHED. Total particles:", particles.length); // DEBUG
                        }
                    }

                    if (this.digProgress >= TILE_SIZE) {
                        const tileRowToClear = this.currentDigTileY;
                        const tileColToClear = Math.floor(digCenterX / TILE_SIZE);
                        const pixelXToClear = tileColToClear * TILE_SIZE + TILE_SIZE / 2;
                        const pixelYToClear = tileRowToClear * TILE_SIZE + TILE_SIZE / 2;
                        if (getTileAt(pixelXToClear, pixelYToClear, map) === '2') {
                             setTileAt(pixelXToClear, pixelYToClear, '0', map);
                        }
                        this.digProgress = 0;
                        this.currentDigTileY++;
                        const groundDirectlyBelow = getTileAt(digCenterX, this.y + this.height + 1, map);
                        if (groundDirectlyBelow === '0') return 'dug_through_to_air';
                        return 'finished_segment';
                    }
                    if (this.actionCounter <= 0) return 'skill_depleted_mid_segment';
                    return 'digging';
                },

                buildStep: function(map) {
                    const frontX = this.x + (this.dx > 0 ? this.width : 0);
                    const stepX = frontX + (this.dx > 0 ? 0 : -TILE_SIZE);
                    const stepY = this.y + this.height - TILE_SIZE;
                    const targetTilePixelX = stepX + TILE_SIZE / 2;
                    const targetTilePixelY = stepY + TILE_SIZE / 2;

                    if (getTileAt(targetTilePixelX, targetTilePixelY, map) === '0') {
                        let canPlace = true;
                        for(const otherLem of lemmings) {
                            if (otherLem === this || otherLem.isDead || otherLem.isRescued) continue;
                            if (targetTilePixelX > otherLem.x && targetTilePixelX < otherLem.x + otherLem.width &&
                                targetTilePixelY > otherLem.y && targetTilePixelY < otherLem.y + otherLem.height) {
                                canPlace = false; break;
                            }
                        }
                        if (canPlace && setTileAt(targetTilePixelX, targetTilePixelY, '2', map)) {
                            return true;
                        }
                    }
                    return false;
                },
                explode: function(map) {
                    console.log(`Lemming ${this.id.toString().substring(0,4)} goes BOOM!`);
                    this.isDead = true; this.state = 'dead_explode';
                    const explosionRadiusPixels = TILE_SIZE * 2.5;
                    const explosionCenterX = this.x + this.width / 2;
                    const explosionCenterY = this.y + this.height / 2;
                    for (let r = -Math.ceil(explosionRadiusPixels / TILE_SIZE); r <= Math.ceil(explosionRadiusPixels / TILE_SIZE); r++) {
                        for (let c = -Math.ceil(explosionRadiusPixels / TILE_SIZE); c <= Math.ceil(explosionRadiusPixels / TILE_SIZE); c++) {
                            const checkX = explosionCenterX + c * TILE_SIZE; const checkY = explosionCenterY + r * TILE_SIZE;
                            const distSq = Math.pow(checkX - explosionCenterX, 2) + Math.pow(checkY - explosionCenterY, 2);
                            if (distSq < explosionRadiusPixels * explosionRadiusPixels) {
                                const tileType = getTileAt(checkX, checkY, map);
                                if (tileType === '1' || tileType === '2' || tileType === 'B') {
                                    setTileAt(checkX, checkY, '0', map);
                                }
                                lemmings.forEach(lem => {
                                    if (lem === this || lem.isDead || lem.isRescued) return;
                                    const lemCenterX = lem.x + lem.width / 2; const lemCenterY = lem.y + lem.height / 2;
                                    const distToLemSq = Math.pow(lemCenterX - explosionCenterX, 2) + Math.pow(lemCenterY - explosionCenterY, 2);
                                    if (distToLemSq < Math.pow(explosionRadiusPixels * 0.8, 2)) {
                                        lem.die("Caught in explosion!");
                                    }
                                });
                            }
                        }
                    }
                },
                die: function(reason) {
                    if (this.isDead) return;
                    this.isDead = true;
                    if (reason === "Splat!") this.state = 'dead_splat';
                    else if (reason === "Caught in explosion!") this.state = 'dead_explode_victim';
                    else this.state = 'dead';
                    console.log(`Lemming ${this.id.toString().substring(0,4)} ${this.state}: ${reason}`);
                },
                rescue: function() {
                    if (this.isRescued || this.isDead) return;
                    this.isRescued = true; this.state = 'rescued';
                    lemmingsRescued++;
                    console.log(`Lemming ${this.id.toString().substring(0,4)} rescued!`);
                }
            };
        }

        function getLemmingBlockerAtPixel(pixelX, pixelY) {
            for (const lem of lemmings) {
                if (!lem.isDead && !lem.isRescued && lem.state === 'blocker') {
                    if (pixelX >= lem.x && pixelX <= lem.x + lem.width &&
                        pixelY >= lem.y && pixelY <= lem.y + lem.height) {
                        return lem;
                    }
                }
            }
            return null;
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) || 16.67; 
            lastTime = timestamp;
            if (!gamePaused && currentGameState === GAME_STATE.PLAYING) {
                update(deltaTime);
                render(deltaTime);
            }
            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            if (deltaTime <= 0 || deltaTime > 500) {
                if (deltaTime <=0 && deltaTime !== 0) { 
                    console.warn("Skipping update due to non-positive deltaTime:", deltaTime);
                    return; 
                }
                if (deltaTime > 500) {
                    console.warn("Capping large deltaTime:", deltaTime);
                    deltaTime = 500; 
                }
            }
            
            if (gamePaused || currentGameState !== GAME_STATE.PLAYING) return;

            const currentTime = performance.now();
            gameTimeRemaining -= deltaTime;
            if (gameTimeRemaining <= 0) {
                gameTimeRemaining = 0;
                endLevel(false);
                return;
            }

            // Use gameLevels from levels.js
            if (gameLevels[currentLevelIndex] && gameLevels[currentLevelIndex].lemmingsToRelease && lemmingsOut < gameLevels[currentLevelIndex].lemmingsToRelease && currentTime - lastReleaseTime > (levelData.releaseRate || 1000)) {
                const entryX = levelData.entryPoint.x * TILE_SIZE + (TILE_SIZE - LEMMING_WIDTH) / 2;
                const entryY = levelData.entryPoint.y * TILE_SIZE;
                lemmings.push(createLemming(entryX, entryY));
                lemmingsOut++;
                lastReleaseTime = currentTime;
            }

            for (let i = lemmings.length - 1; i >= 0; i--) {
                lemmings[i].update(deltaTime, levelData.map);
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(deltaTime);
                // console.log(`Particle ${i} life: ${particles[i].life.toFixed(2)}, deltaTime: ${deltaTime.toFixed(2)}`); // DEBUG: Particle life
                if (particles[i].life <= 0) {
                    // console.log(`Splicing particle ${i}`); // DEBUG: Particle splicing
                    particles.splice(i, 1);
                }
            }
            updateGameInfo();

            let activeLemmingsCount = 0;
            for(const lem of lemmings) { if(!lem.isDead && !lem.isRescued) activeLemmingsCount++; }

            if (lemmingsToSave > 0 && lemmingsRescued >= lemmingsToSave) {
                endLevel(true);
            } else if (levelData.lemmingsToRelease && lemmingsOut >= levelData.lemmingsToRelease && activeLemmingsCount === 0 && lemmingsRescued < lemmingsToSave) {
                endLevel(false);
            }
        }
        function render(deltaTime) {
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (levelData.map) {
                for (let y = 0; y < levelData.map.length; y++) {
                    for (let x = 0; x < levelData.map[y].length; x++) {
                        const tile = levelData.map[y][x];
                        if (tile === '1') { ctx.fillStyle = 'brown';}
                        else if (tile === '2') { ctx.fillStyle = 'sandybrown';}
                        else if (tile === 'E') { ctx.fillStyle = 'blue';}
                        else if (tile === 'X') { ctx.fillStyle = 'green';}
                        else { continue; } 
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
            for (const lem of lemmings) { lem.draw(ctx); }
            for (const particle of particles) { particle.draw(ctx); }
            
            if (tapVisualTimer > 0) {
                tapVisualTimer -= deltaTime;
                if (lastTapPos) {
                    const radius = 15 * Math.max(0, (tapVisualTimer / TAP_VISUAL_DURATION));
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(lastTapPos.x, lastTapPos.y, radius, 0, Math.PI * 2); ctx.stroke();
                    ctx.lineWidth = 1;
                }
            } else { lastTapPos = null; }

            if (interactionFeedbackTimer > 0) {
                interactionFeedbackTimer -= deltaTime;
                if (interactionFeedbackTimer <= 0) { lastInteractionLemming = null; }
            }
        }
        function getTouchPos(canvasDom, touchEvent) {
            const rect = canvasDom.getBoundingClientRect();
            const scaleX = canvasDom.width / rect.width;
            const scaleY = canvasDom.height / rect.height;
            return {
                x: (touchEvent.touches[0].clientX - rect.left) * scaleX,
                y: (touchEvent.touches[0].clientY - rect.top) * scaleY
            };
        }
        function handleCanvasTap(event) {
            event.preventDefault();
            const pos = getTouchPos(canvas, event);
            lastTapPos = pos; tapVisualTimer = TAP_VISUAL_DURATION;
            let lemmingWasTapped = false;

            for (let i = lemmings.length - 1; i >= 0; i--) {
                const lem = lemmings[i];
                if (lem.isDead || lem.isRescued) continue;
                if (pos.x >= lem.x && pos.x <= lem.x + lem.width &&
                    pos.y >= lem.y && pos.y <= lem.y + lem.height) {
                    lemmingWasTapped = true;
                    if (selectedSkill) {
                        if (lem.assignSkill(selectedSkill)) {
                            lastInteractionLemming = lem; interactionFeedbackTimer = INTERACTION_FEEDBACK_DURATION;
                            highlightedLemming = null; 
                        } else { highlightedLemming = lem; lastInteractionLemming = null; }
                    } else { highlightedLemming = lem; lastInteractionLemming = null; }
                    break; 
                }
            }
            if (!lemmingWasTapped) { highlightedLemming = null; lastInteractionLemming = null; }
        }
        canvas.addEventListener('touchstart', handleCanvasTap, { passive: false });
        
        function setupSkillButtons() {
            uiControls.innerHTML = '';
            if (!levelData || !levelData.availableSkills) return;
            const skills = Object.keys(levelData.availableSkills);
            skills.forEach(skillName => {
                const button = document.createElement('button');
                button.classList.add('skillButton'); button.id = `${skillName}Btn`;
                button.dataset.skill = skillName;
                const count = levelData.availableSkills[skillName] === undefined ? 0 : levelData.availableSkills[skillName];
                button.textContent = `${skillName.charAt(0).toUpperCase() + skillName.slice(1)} (${count === Infinity ? '∞' : count})`;
                 if (count === 0) button.disabled = true; // Disable if initially 0
                button.addEventListener('click', () => {
                    if (selectedSkill === skillName) {
                        selectedSkill = null; button.classList.remove('active');
                    } else {
                        document.querySelector('.skillButton.active')?.classList.remove('active');
                        selectedSkill = skillName; button.classList.add('active');
                    }
                });
                uiControls.appendChild(button);
            });
        }
        
        function updateSkillButtons() {
            const buttons = document.querySelectorAll('.skillButton');
            buttons.forEach(button => {
                const skillName = button.dataset.skill;
                if (levelData.availableSkills && levelData.availableSkills[skillName] !== undefined) {
                    const count = levelData.availableSkills[skillName];
                    button.textContent = `${skillName.charAt(0).toUpperCase() + skillName.slice(1)} (${count === Infinity ? '∞' : count})`;
                    if (count === 0 && selectedSkill !== skillName) {
                        button.disabled = true;
                    } else {
                        button.disabled = false;
                    }
                } else { 
                    button.textContent = `${skillName.charAt(0).toUpperCase() + skillName.slice(1)} (N/A)`;
                    button.disabled = true;
                }
            });
        }

        function updateGameInfo() {
            const totalLemmingsInLevel = levelData.lemmingsToRelease || 0;
            let activeLemmings = 0;
            lemmings.forEach(l => { if (!l.isDead && !l.isRescued) activeLemmings++;});
            lemmingsCountEl.textContent = `Active: ${activeLemmings}`;
            lemmingsSavedEl.textContent = `Saved: ${lemmingsRescued} / ${lemmingsToSave || '?'}`;
            timeLeftEl.textContent = `Time: ${Math.max(0, Math.ceil(gameTimeRemaining / 1000))}`;
            levelNameEl.textContent = `Level: ${levelData.name || (currentLevelIndex + 1)}`;
        }

        function showLoadingScreen(show) { loadingScreen.style.display = show ? 'flex' : 'none'; }
        
        function simulateLoading() {
            showLoadingScreen(true);
            console.log("Simulating asset loading...");
            setTimeout(() => {
                showLoadingScreen(false);
                currentGameState = GAME_STATE.PLAYING;
                startLevel(currentLevelIndex);
            }, 500);
        }

        function startLevel(levelIndex) {
            if (typeof gameLevels === 'undefined' || !gameLevels || gameLevels.length === 0) {
                console.error("gameLevels array is not defined or empty! Make sure levels.js is loaded and defines gameLevels.");
                alert("Error: Level data not found!");
                return;
            }
            if (levelIndex >= gameLevels.length) {
                currentGameState = GAME_STATE.MENU; 
                ctx.fillStyle = 'gold'; ctx.fillRect(0,0,canvas.width, canvas.height);
                ctx.fillStyle = 'black'; ctx.font = '30px Arial'; ctx.textAlign = 'center';
                ctx.fillText("ALL LEVELS COMPLETE!", canvas.width/2, canvas.height/2);
                return;
            }
            currentLevelIndex = levelIndex;
            levelData = JSON.parse(JSON.stringify(gameLevels[currentLevelIndex]));

            const mapWidth = levelData.map[0].length * TILE_SIZE;
            const mapHeight = levelData.map.length * TILE_SIZE;
            canvas.width = mapWidth;
	    canvas.height = mapHeight;

            lemmings = [];
	    particles = []; 
            lemmingsOut = 0;
	    lemmingsRescued = 0;
            lemmingsToSave = levelData.requiredToSave;
            gameTimeRemaining = levelData.time * 1000;
            releaseRate = levelData.releaseRate || 1000;
            lastReleaseTime = performance.now();
            selectedSkill = null;
	    gamePaused = false;
            highlightedLemming = null;
	    lastInteractionLemming = null;

            setupSkillButtons();
            updateGameInfo(); 
            currentGameState = GAME_STATE.PLAYING;
            console.log(`Starting Level: ${levelData.name} (Req: ${lemmingsToSave})`);
        }

        function endLevel(success) {
            gamePaused = true;
            currentGameState = success ? GAME_STATE.LEVEL_COMPLETE : GAME_STATE.GAME_OVER;
            selectedSkill = null;
	    highlightedLemming = null;
	    lastInteractionLemming = null;
            document.querySelector('.skillButton.active')?.classList.remove('active');
            setTimeout(() => {
                const message = success ? 
                    `Level Complete!\nSaved: ${lemmingsRescued}/${lemmingsToSave}` :
                    `Level Failed.\nSaved: ${lemmingsRescued}, Needed: ${lemmingsToSave}`;
                alert(message);
                if (success) {
		    currentLevelIndex++;
		    startLevel(currentLevelIndex);
                } else {
		    startLevel(currentLevelIndex);
		}
            }, 1000);
        }

        function init() {
            if (typeof gameLevels === 'undefined') {
                console.error("gameLevels is not defined. Ensure levels.js is loaded before this script.");
                alert("Error: Level data not found! Check console.");
                loadingScreen.innerHTML = "Error loading levels!";
		showLoadingScreen(true);
		return;
            }
            lastReleaseTime = performance.now();
            simulateLoading();
            requestAnimationFrame(gameLoop);
        }
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
